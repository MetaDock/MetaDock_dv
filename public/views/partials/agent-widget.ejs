<!-- Agent Widget -->
<div id="agent-widget-container" class="fixed bottom-5 right-5 z-50">
  <!-- FAB Button -->
  <button id="agent-fab" class="btn btn-primary btn-circle btn-lg shadow-lg" onclick="toggleAgentChat()">
    <i id="agent-icon" class="ti ti-message-chatbot text-3xl"></i>
  </button>

  <!-- Chat Popup -->
  <div id="agent-chat-popup" class="hidden fixed bg-base-100 rounded-lg shadow-2xl border border-base-300 flex flex-col" style="width: 24rem; height: 32rem; bottom: 5.5rem; right: 1.25rem;">
    <!-- Header -->
    <div id="chat-header" class="card-title bg-base-200 p-4 flex items-center justify-between cursor-move">
      <h2 class="text-lg font-bold flex items-center">
        <i class="ti ti-message-chatbot mr-2"></i> Bioinfo Agent
      </h2>
      <div>
        <button id="clear-chat-btn" class="btn btn-sm btn-ghost btn-circle" title="Clear chat history">
            <i class="ti ti-trash"></i>
        </button>
        <button class="btn btn-sm btn-ghost btn-circle" onclick="toggleAgentChat()">
            <i class="ti ti-x"></i>
        </button>
      </div>
    </div>

    <!-- Chat Body -->
    <div id="chat-body" class="card-body flex-grow p-4 overflow-y-auto bg-base-100" style="flex: 1 1 auto;">
      <!-- Messages will be appended here -->
      <div class="chat chat-start">
        <div class="chat-bubble chat-bubble-primary">
          Hello! How can I help you with bioinformatics tools today?
        </div>
      </div>
    </div>

    <!-- Input Area -->
    <div class="card-footer bg-base-200 p-4 border-t border-base-300">
      <div class="flex items-center space-x-2">
        <input type="text" id="chat-input" class="input input-bordered w-full" placeholder="Ask a question..." autocomplete="off">
        <button id="chat-send-btn" class="btn btn-primary btn-circle">
          <i class="ti ti-send"></i>
        </button>
      </div>
    </div>
    <!-- Resize Handles -->
    <div class="resize-handle n"></div><div class="resize-handle s"></div>
    <div class="resize-handle e"></div><div class="resize-handle w"></div>
    <div class="resize-handle nw"></div><div class="resize-handle ne"></div>
    <div class="resize-handle sw"></div><div class="resize-handle se"></div>
  </div>
</div>

<script>
  const agentFab = document.getElementById('agent-fab');
  const agentChatPopup = document.getElementById('agent-chat-popup');
  const agentIcon = document.getElementById('agent-icon');
  const chatHeader = document.getElementById('chat-header');
  const clearChatBtn = document.getElementById('clear-chat-btn');
  const chatBody = document.getElementById('chat-body');
  const chatInput = document.getElementById('chat-input');
  const chatSendBtn = document.getElementById('chat-send-btn');

  function toggleAgentChat() {
    agentChatPopup.classList.toggle('hidden');
    if (agentChatPopup.classList.contains('hidden')) {
      agentIcon.classList.remove('ti-x');
      agentIcon.classList.add('ti-message-chatbot');
    } else {
      agentIcon.classList.remove('ti-message-chatbot');
      agentIcon.classList.add('ti-x');
    }
    saveState();
  }

  // --- Dragging & Resizing Logic ---
  let isDragging = false;
  let isResizing = false;
  let resizeDirection = '';
  let offsetX, offsetY, lastX, lastY;

  chatHeader.addEventListener('mousedown', (e) => {
    // Prevent starting a drag on the close button
    if (e.target.closest('button')) return;
    isDragging = true;
    offsetX = e.clientX - agentChatPopup.offsetLeft;
    offsetY = e.clientY - agentChatPopup.offsetTop;
    agentChatPopup.style.userSelect = 'none';
  });

  agentChatPopup.querySelectorAll('.resize-handle').forEach(handle => {
    handle.addEventListener('mousedown', (e) => {
        isResizing = true;
        resizeDirection = e.target.className.split(' ')[1];
        lastX = e.clientX;
        lastY = e.clientY;
        document.body.style.cursor = getComputedStyle(e.target).cursor;
        agentChatPopup.style.userSelect = 'none';
        e.stopPropagation();
        e.preventDefault();
    });
  });

  document.addEventListener('mousemove', (e) => {
    if (isDragging) {
        e.preventDefault();
        agentChatPopup.style.left = `${e.clientX - offsetX}px`;
        agentChatPopup.style.top = `${e.clientY - offsetY}px`;
        agentChatPopup.style.bottom = 'auto';
        agentChatPopup.style.right = 'auto';
    } else if (isResizing) {
        e.preventDefault();
        
        const rect = agentChatPopup.getBoundingClientRect();
        let newWidth = rect.width;
        let newHeight = rect.height;
        let newLeft = rect.left;
        let newTop = rect.top;
        
        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;

        if (resizeDirection.includes('e')) newWidth += deltaX;
        if (resizeDirection.includes('w')) {
            newWidth -= deltaX;
            newLeft += deltaX;
        }
        if (resizeDirection.includes('s')) newHeight += deltaY;
        if (resizeDirection.includes('n')) {
            newHeight -= deltaY;
            newTop += deltaY;
        }

        // Apply minimum size constraints and update style
        if (newWidth >= 300) {
            agentChatPopup.style.width = `${newWidth}px`;
            if (resizeDirection.includes('w')) agentChatPopup.style.left = `${newLeft}px`;
        }
        if (newHeight >= 200) {
            agentChatPopup.style.height = `${newHeight}px`;
            if (resizeDirection.includes('n')) agentChatPopup.style.top = `${newTop}px`;
        }
        
        lastX = e.clientX;
        lastY = e.clientY;
    }
  });

  document.addEventListener('mouseup', () => {
    if (isDragging || isResizing) {
      isDragging = false;
      isResizing = false;
      resizeDirection = '';
      agentChatPopup.style.userSelect = 'auto';
      document.body.style.cursor = 'auto';
      saveState();
    }
  });
  
  function addMessage(message, sender) {
      const chatClass = sender === 'user' ? 'chat-end' : 'chat-start';
      const bubbleClass = sender === 'user' ? 'chat-bubble-secondary' : 'chat-bubble-primary';
      
      const messageElement = document.createElement('div');
      messageElement.className = `chat ${chatClass}`;
      
      const bubble = document.createElement('div');
      bubble.className = `chat-bubble ${bubbleClass}`;
      bubble.innerHTML = message; // Using innerHTML to render markdown (if any)
      
      messageElement.appendChild(bubble);
      chatBody.appendChild(messageElement);
      chatBody.scrollTop = chatBody.scrollHeight;
  }

  function setAgentStatus(ready) {
      if (ready) {
          chatInput.disabled = false;
          chatSendBtn.disabled = false;
          chatInput.placeholder = "Ask a question...";
      } else {
          chatInput.disabled = true;
          chatSendBtn.disabled = true;
          chatInput.placeholder = "Initializing agent...";
      }
  }

  async function checkAgentStatusLoop() {
      try {
          const response = await fetch('/api/agent/status');
          const data = await response.json();
          setAgentStatus(data.ready);
          if (!data.ready) {
              setTimeout(checkAgentStatusLoop, 2500); // Poll again
          }
      } catch (e) {
          setAgentStatus(false);
          setTimeout(checkAgentStatusLoop, 2500); // Poll again on error
      }
  }

  async function askAgent(question) {
    addMessage(question, 'user');
    chatInput.value = '';
    chatInput.disabled = true;
    chatSendBtn.disabled = true;

    // Create a new, empty message bubble for the agent's response
    const agentMessageElement = document.createElement('div');
    agentMessageElement.className = 'chat chat-start';
    const agentBubble = document.createElement('div');
    agentBubble.className = 'chat-bubble chat-bubble-primary';
    // Add a dedicated container for markdown content
    agentBubble.innerHTML = '<div class="markdown-content"><span class="blinking-cursor"></span></div>'; 
    agentMessageElement.appendChild(agentBubble);
    chatBody.appendChild(agentMessageElement);
    chatBody.scrollTop = chatBody.scrollHeight;

    let fullAnswer = '';
    let sources = [];

    try {
      const response = await fetch('/api/agent/ask', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ question }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Agent API error');
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      // Set up the content container
      const markdownContainer = agentBubble.querySelector('.markdown-content');
      markdownContainer.innerHTML = ''; // Remove blinking cursor

      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\\n\\n');
        buffer = lines.pop(); // Keep the last, potentially incomplete line

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const jsonStr = line.substring(6);
            try {
                const event = JSON.parse(jsonStr);

                if (event.type === 'chunk' && event.content) {
                    fullAnswer += event.content;
                    markdownContainer.innerHTML = marked.parse(fullAnswer + '<span class="blinking-cursor"></span>');
                    chatBody.scrollTop = chatBody.scrollHeight;
                } else if (event.type === 'sources' && event.sources) {
                    sources = event.sources;
                } else if (event.type === 'final_data') {
                    // In our new flow, final data is also handled via chunks and sources events
                    // But we can grab the final answer here if needed.
                    if (event.answer) fullAnswer = event.answer;
                    if (event.sources) sources = event.sources;
                } else if (event.type === 'error') {
                    throw new Error(event.error);
                }
            } catch (e) {
                console.error('Failed to parse stream event:', jsonStr, e);
            }
          }
        }
      }

      // Final update to the bubble without the cursor
      const finalMarkdown = marked.parse(fullAnswer);
      let sourcesHtmlContent = '';
      if (sources && sources.length > 0) {
        let sourcesHtml = '<hr class="my-2 border-base-300/50"><div class="text-xs mt-2 opacity-70"><strong>Sources:</strong><ul class="list-disc list-inside">';
        let hasValidSource = false;
        sources.forEach(source => {
            if (source && source.source) {
                sourcesHtml += `<li>${source.source}</li>`;
                hasValidSource = true;
            }
        });
        sourcesHtml += '</ul></div>';
        
        if (hasValidSource) {
            sourcesHtmlContent = sourcesHtml;
        }
      }
      markdownContainer.innerHTML = finalMarkdown + sourcesHtmlContent;
      chatBody.scrollTop = chatBody.scrollHeight;
      saveState();

    } catch (error) {
      console.error('Error asking agent:', error);
      agentBubble.classList.add('chat-bubble-error');
      agentBubble.innerHTML = `Sorry, I encountered an error: ${error.message}`;
      saveState();
    } finally {
      chatInput.disabled = false;
      chatSendBtn.disabled = false;
      chatInput.focus();
    }
  }

  chatSendBtn.addEventListener('click', () => {
    const question = chatInput.value.trim();
    if (question) {
      askAgent(question);
    }
  });

  chatInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      const question = chatInput.value.trim();
      if (question) {
        askAgent(question);
      }
    }
  });

  clearChatBtn.addEventListener('click', (e) => {
    e.stopPropagation(); // Prevent drag from starting
    clearChatHistory();
  });

  function clearChatHistory() {
    chatBody.innerHTML = `
        <div class="chat chat-start">
            <div class="chat-bubble chat-bubble-primary">
                <div class="markdown-content"><p>Hello! How can I help you with bioinformatics tools today?</p></div>
            </div>
        </div>
    `;
    saveState();
  }

  // --- State Persistence ---
  function saveState() {
    const state = {
      history: chatBody.innerHTML,
      position: {
        left: agentChatPopup.style.left,
        top: agentChatPopup.style.top,
      },
      size: {
        width: agentChatPopup.style.width,
        height: agentChatPopup.style.height,
      },
      isOpen: !agentChatPopup.classList.contains('hidden'),
    };
    localStorage.setItem('agentWidgetState', JSON.stringify(state));
  }

  function loadState() {
    const savedState = localStorage.getItem('agentWidgetState');
    if (!savedState) return;

    const state = JSON.parse(savedState);
    
    if (state.history) {
      chatBody.innerHTML = state.history;
      chatBody.scrollTop = chatBody.scrollHeight;
    }

    if (state.position && state.position.left && state.position.top) {
      agentChatPopup.style.left = state.position.left;
      agentChatPopup.style.top = state.position.top;
      agentChatPopup.style.bottom = 'auto';
      agentChatPopup.style.right = 'auto';
    }

    if (state.size && state.size.width && state.size.height) {
      agentChatPopup.style.width = state.size.width;
      agentChatPopup.style.height = state.size.height;
    }

    if (state.isOpen) {
      agentChatPopup.classList.remove('hidden');
      agentIcon.classList.remove('ti-message-chatbot');
      agentIcon.classList.add('ti-x');
    } else {
      agentChatPopup.classList.add('hidden');
      agentIcon.classList.remove('ti-x');
      agentIcon.classList.add('ti-message-chatbot');
    }
  }

  // Initial status check and state load
  document.addEventListener('DOMContentLoaded', () => {
    loadState();
    checkAgentStatusLoop();
  });
</script>
<style>
.resize-handle {
    position: absolute;
    z-index: 5;
}
.resize-handle.n { top: -3px; left: 5px; right: 5px; height: 6px; cursor: ns-resize; }
.resize-handle.s { bottom: -3px; left: 5px; right: 5px; height: 6px; cursor: ns-resize; }
.resize-handle.e { top: 5px; bottom: 5px; right: -3px; width: 6px; cursor: ew-resize; }
.resize-handle.w { top: 5px; bottom: 5px; left: -3px; width: 6px; cursor: ew-resize; }
.resize-handle.nw { top: -3px; left: -3px; width: 12px; height: 12px; cursor: nwse-resize; z-index: 10; }
.resize-handle.ne { top: -3px; right: -3px; width: 12px; height: 12px; cursor: nesw-resize; z-index: 10; }
.resize-handle.sw { bottom: -3px; left: -3px; width: 12px; height: 12px; cursor: nesw-resize; z-index: 10; }
.resize-handle.se { bottom: -3px; right: -3px; width: 12px; height: 12px; cursor: nwse-resize; z-index: 10; }

#agent-widget {
  transition: all 0.3s ease-in-out;
}
.blinking-cursor {
  display: inline-block;
  width: 8px;
  height: 1.2em;
  background-color: currentColor;
  animation: blink 1s step-end infinite;
  vertical-align: bottom;
}

@keyframes blink {
  50% {
    opacity: 0;
  }
}
</style>
<style>
/* Style for the markdown container */

/* Markdown Content Styling */
.chat-bubble pre {
  background-color: #2a303c; /* Darker background for code blocks */
  color: #d1d5db;          /* Lighter text for contrast */
  padding: 0.75rem;
  border-radius: 0.5rem;
  overflow-x: auto;       /* Add horizontal scroll for wide code */
  white-space: pre-wrap;    /* Wrap long lines */
  word-wrap: break-word;    /* Break long words */
  max-width: 100%;
}

.chat-bubble pre code {
  font-family: Consolas, 'Courier New', monospace;
  font-size: 0.875rem;
  background-color: transparent; /* Code tag inside pre should be transparent */
  padding: 0;
}

/* Inline code snippets */
.chat-bubble :not(pre) > code {
  background-color: rgba(97, 106, 122, 0.5);
  padding: 0.1rem 0.3rem;
  border-radius: 0.25rem;
  font-size: 0.85em;
}

/* Other markdown elements */
.chat-bubble ul, .chat-bubble ol {
  padding-left: 1.5rem; /* Indent lists */
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
}
.chat-bubble hr {
    border-color: rgba(255, 255, 255, 0.1);
}

/* Fix for markdown headings and paragraphs */
.markdown-content > p,
.markdown-content > ul,
.markdown-content > ol,
.markdown-content > pre,
.markdown-content > blockquote,
.markdown-content > hr {
    margin-bottom: 0.8rem;
}

.markdown-content > h1, .markdown-content > h2, .markdown-content > h3, .markdown-content > h4, .markdown-content > h5, .markdown-content > h6 {
    margin-top: 1.2rem; 
    margin-bottom: 0.6rem; 
    line-height: 1.25;
    font-weight: 600;
}

.markdown-content > h1 { font-size: 1.2em; }
.markdown-content > h2 { font-size: 1.1em; }
.markdown-content > h3 { font-size: 1.05em; }

.markdown-content > *:last-child {
    margin-bottom: 0;
}

.chat-bubble h1, .chat-bubble h2, .chat-bubble h3, .chat-bubble h4, .chat-bubble h5, .chat-bubble h6 {
    margin-top: 0;
    margin-bottom: 0;
    line-height: 1.25;
    font-weight: 600;
}
.chat-bubble h1 { font-size: 1.2em; }
.chat-bubble h2 { font-size: 1.1em; }
.chat-bubble h3 { font-size: 1.05em; }

.chat-bubble p {
    margin-bottom: 0;
}
/* Ensure the last element in a bubble doesn't have a bottom margin */
.chat-bubble > *:last-child {
    margin-bottom: 0;
}
</style> 